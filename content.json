[{"title":"hexo主题配置","date":"2017-04-15T16:00:00.000Z","path":"2017/04/16/hexo主题配置/","text":"选择hexo很重要的一个原因就是它丰富的主题，而配置主题的流程也很简单：1、clone主题到本地2、修改_config.yml配置3、重新生成静态页面、发布 下载主题hexo官网有很多丰富的主题，选择一个，进入到它的GitHub页面12$ cd yourBlogdir/themes$ git clone xxx.git 修改配置打开博客根目录下的_config.yml配置文件，找到theme: 节点，将值改成下载的主题名。如：1theme: yilia 重新发布123$ hexo clean //删除本地原有静态页面$ hexo g //重新生成静态页面$ hexo d //发布到GitHub 一个新的主题，肯定会存在一些个性化的配置，这些就需要去看对应主题的相关readme了","tags":[{"name":"主题","slug":"主题","permalink":"http://zhanglong.wiki/tags/主题/"}]},{"title":"Hexo + Github Pages 搭建静态博客","date":"2017-04-15T16:00:00.000Z","path":"2017/04/16/hexo/","text":"利用hexo和github pages搭建静态博客，主要操作步骤有： 1、搭建node.js环境 2、安装hexo 3、用hexo初始化生成一个静态博客文件 4、生成静态html页面 5、本地起服务调试 6、配置github仓库地址 7、发布 安装Node.jsURL: 下载 安装Hexo1$ sudo npm install -g hexo 初始化1$ hexo init INFO Start blogging with Hexo! 生成静态页面1$ hexo g 启动服务hexo可以在本地调试，1$ hexo server 配置发布信息Github打开根目录_config.yml 在文件最后，修改deploy节点1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 执行命令1$ npm install hexo-deployer-git --save 发布1$ hexo deploy","tags":[]},{"title":"ArrayList源码笔记(1.8)","date":"2017-01-09T16:00:00.000Z","path":"2017/01/10/ArrayList源码笔记/","text":"ArrayList 是一个依靠 Arrays.copyOf 方法进行动态扩展的数组。增删改查本质上都是对数组进行操作，只是存在容量动态扩展的的逻辑 简介ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 线程不安全。 属性12345678910111213141516171819202122/** * 默认初始容量. */private static final int DEFAULT_CAPACITY = 10;/** * 空数组，构造初始容量为0时使用 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 默认初始化数组. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存List数据的数组，如果List是默认初始化，当第一个元素添加时，elementData大小变成DEFAULT_CAPACITY */transient Object[] elementData; // transient不参与序列化（由readObjet()，writeObject()解决序列/反序列初始化问题）/** * 容器里元素个数 * @serial */private int size; 构造函数1234567891011121314151617181920212223242526272829303132/** 指定List大小 */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;/** * 默认 */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * 一个包含Collection的List */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // c大小为0 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 容量调整方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 将数组大小设置为元素个数 */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125;/** * 让用户设置容器大小 */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;/** * 确认容器大小，如果容器是默认初始化，则最小容量置为DEFAULT_CAPACITY【检查1】 */private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;/** * 确认容器大小，如果最小期望的容量不够，则增加【检查2】 */private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * 数组可以分配的最大值 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * 增加数组容量，使之能达到期望大小 * @param minCapacity 期望的最小容量 */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;/** * 获取一个大的容量 */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 增删改查增提供的添加方法有add(E e),add(int index, E element),addAll(Collection&lt;? extends E&gt; c),addAll(int index, Collection&lt;? extends E&gt; c) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 添加元素 */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 确认容量，长度不足就扩容 elementData[size++] = e; return true;&#125;/** * 添加到指定位置 */public void add(int index, E element) &#123; rangeCheckForAdd(index);//检查index有没有大于当前元素个数，有没有小于0 ensureCapacityInternal(size + 1); // 确认容量，长度不足就扩容 System.arraycopy(elementData, index, elementData, index + 1, size - index);//index后面的统一往后移一位 elementData[index] = element; size++;&#125;/** * 增加一个Collection */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 确认容量，长度不足就扩容 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;/** * 将Collection插入到指定位置 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 删删除的方法remove(int index),remove(Object o),fastRemove(int index),clear(),removeAll(Collection&lt;?&gt; c),retainAll(Collection&lt;?&gt; c),removeRange(int fromIndex, int toIndex) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 删除指定位置元素 */public E remove(int index) &#123; rangeCheck(index);//index边界检查 modCount++;//新增修改记录数 E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;/** * 删除指定元素，首个出现的 */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/* * 删除指定位置元素，不做index越界检查 */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;/** * 删除所有 */public void clear() &#123; modCount++; //变更修改次数 // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125;/** * 批量删除 删除包含C的 */public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125;/** * 批量删除 删除不包含C的 */public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125;/** * 删除从fromIndex到toIndex的元素 */protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125; 改12345678910/** * 修改index位置的元素 */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 查查询方法get(int index),indexOf(Object o),indexOf(Object o),indexOf(Object o),contains(Object o) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 获取指定位置的元素 */public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125;/** * 遍历查找O首次出现的位置，没有返回-1 */public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * 返回o出现的最后一次位置 */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * 是否包含 */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 序列化一句话：都是流 并发线程不安全 [参考]http://www.cnblogs.com/skywang12345/p/3308556.html","tags":[{"name":"源码","slug":"源码","permalink":"http://zhanglong.wiki/tags/源码/"},{"name":"jdk","slug":"jdk","permalink":"http://zhanglong.wiki/tags/jdk/"},{"name":"集合","slug":"集合","permalink":"http://zhanglong.wiki/tags/集合/"}]},{"title":"LinkedList源码笔记(1.8)","date":"2017-01-09T16:00:00.000Z","path":"2017/01/10/LinkedList源码笔记/","text":"LinkedList 双向链表。插入删除，最多都只需要修改三个Node，速度较快根据index查询，最多需要遍历半个链表（node(int index) 方法会判断从头遍历还是从尾遍历） 简介 构造函数1234567public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 属性12345transient int size = 0; //元素个数 transient Node&lt;E&gt; first; //链表头transient Node&lt;E&gt; last; //链表尾 Node1234567891011private static class Node&lt;E&gt; &#123; E item;//存储元素 Node&lt;E&gt; next;//下一个 Node&lt;E&gt; prev;//上一个 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 增删改查增123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 在链表末端插入一个元素 */public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * 在链表末端插入一个元素 */public void addLast(E e) &#123; linkLast(e);&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last;//获取链表尾节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);//创建Node节点 last = newNode;//修改链表尾节点 if (l == null)//链表是空的 first = newNode; else l.next = newNode; size++; modCount++;&#125;/** * 在链表首端插入一个元素 */public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125; 删1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 删除首节点 * 如果链表没有元素，会报NoSuchElementException */public E remove() &#123; return removeFirst();&#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;/** * 删除指定位置元素 */public E remove(int index) &#123; checkElementIndex(index);//检查index边界 return unlink(node(index));&#125;/** * 找到第index个Node */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; //index小于size一半，从头节点开始遍历 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123;//从尾节点开始遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;/** * 移除指定节点 */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; //C final Node&lt;E&gt; prev = x.prev; //A if (prev == null) &#123; first = next; //如果是头，直接把next设置为头 &#125; else &#123; prev.next = next; //A-&gt;B-&gt;C ==&gt; A-&gt;C x.prev = null; &#125; if (next == null) &#123; last = prev; //如果是尾，直接prev设置为尾 &#125; else &#123; next.prev = prev; //A&lt;-B&lt;-C ==&gt; A&lt;-C x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125;/** * 删除尾节点 */public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125; 改1234567891011/** * 修改 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; checkElementIndex(index);//检查边界 Node&lt;E&gt; x = node(index);//找到指定index的Node E oldVal = x.item; x.item = element; return oldVal;&#125; 查12345678/** * 查找 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; 队列、栈LinkedList可以不作任何修改，直接当做队列，栈使用。","tags":[{"name":"源码","slug":"源码","permalink":"http://zhanglong.wiki/tags/源码/"},{"name":"jdk","slug":"jdk","permalink":"http://zhanglong.wiki/tags/jdk/"},{"name":"集合","slug":"集合","permalink":"http://zhanglong.wiki/tags/集合/"}]}]