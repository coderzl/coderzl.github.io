<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[基于Mysql的Sequence实现]]></title>
      <url>%2F2017%2F06%2F12%2Fframework%2F%E5%9F%BA%E4%BA%8EMysql%E7%9A%84Sequence%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[之前有提到过，团队更换新框架。新的业务全部使用新的框架，甚至是新的数据库–Mysql。这边之前一直是使用oracle，各种订单号、流水号、批次号啥的，都是直接使用oracle的sequence提供的数字序列号。现在数据库更换成Mysql了，显然以前的老方法不能适用了。 需要新写一个： 分布式场景使用 满足一定的并发要求找了一些相关的资料，发现mysql这方面的实现，原理都是一条数据库记录，不断update它的值。然后大部分的实现方案，都用到了函数。贴一下网上的代码：基于mysql函数实现表结构 12345678910111213141516171819202122232425262728CREATE TABLE `t_sequence` (`sequence_name` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '序列名称' ,`value` int(11) NULL DEFAULT NULL COMMENT '当前值' ,PRIMARY KEY (`sequence_name`))ENGINE=InnoDBDEFAULT CHARACTER SET=utf8 COLLATE=utf8_general_ciROW_FORMAT=COMPACT;``` &lt;!-- more --&gt;#### 获取下一个值```sqlCREATE DEFINER = `root`@`localhost` FUNCTION `nextval`(sequence_name varchar(64)) RETURNS int(11)BEGIN declare current integer; set current = 0; update t_sequence t set t.value = t.value + 1 where t.sequence_name = sequence_name; select t.value into current from t_sequence t where t.sequence_name = sequence_name; return current;end; 并发场景有可能会出问题吧，虽然可以在业务层加锁，但分布式场景就无法保证了，然后效率应该也不会高。自己实现一个，java版 原理： 读取一条记录，缓存一个数据段，如：0-100，将记录的当前值从0修改为100 数据库乐观锁更新，允许重试 读取数据从缓存中读取，用完再读取数据库不废话，上代码：基于java实现表结构12345678910CREATE TABLE `t_pub_sequence` ( `SEQ_NAME` varchar(128) CHARACTER SET utf8 NOT NULL COMMENT '序列名称', `SEQ_VALUE` bigint(20) NOT NULL COMMENT '目前序列值', `MIN_VALUE` bigint(20) NOT NULL COMMENT '最小值', `MAX_VALUE` bigint(20) NOT NULL COMMENT '最大值', `STEP` bigint(20) NOT NULL COMMENT '每次取值的数量', `TM_CREATE` datetime NOT NULL COMMENT '创建时间', `TM_SMP` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间', PRIMARY KEY (`SEQ_NAME`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='流水号生成表'; sequence接口1234567891011121314151617/** * &lt;p&gt;&lt;/p&gt; * @author coderzl * @Title MysqlSequence * @Description 基于mysql数据库实现的序列 * @date 2017/6/6 23:03 */public interface MysqlSequence &#123; /** * &lt;p&gt; * 获取指定sequence的序列号 * &lt;/p&gt; * @param seqName sequence名 * @return String 序列号 */ public String nextVal(String seqName);&#125; 序列区间 用于本地缓存一段序列，从min到max区间123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * &lt;p&gt;&lt;/p&gt; * * @author coderzl * @Title SequenceRange * @Description 序列区间，用于缓存序列 * @date 2017/6/6 22:58 */ @Datapublic class SequenceRange &#123; private final long min; private final long max; /** */ private final AtomicLong value; /** 是否超限 */ private volatile boolean over = false; /** * 构造. * * @param min * @param max */ public SequenceRange(long min, long max) &#123; this.min = min; this.max = max; this.value = new AtomicLong(min); &#125; /** * &lt;p&gt;Gets and increment&lt;/p&gt; * * @return */ public long getAndIncrement() &#123; long currentValue = value.getAndIncrement(); if (currentValue &gt; max) &#123; over = true; return -1; &#125; return currentValue; &#125;&#125; BO 对应数据库记录1234567891011121314151617181920212223242526272829303132333435@Datapublic class MysqlSequenceBo &#123; /** * seq名 */ private String seqName; /** * 当前值 */ private Long seqValue; /** * 最小值 */ private Long minValue; /** * 最大值 */ private Long maxValue; /** * 每次取值的数量 */ private Long step; /** */ private Date tmCreate; /** */ private Date tmSmp; public boolean validate()&#123; //一些简单的校验。如当前值必须在最大最小值之间。step值不能大于max与min的差 if (StringUtil.isBlank(seqName) || minValue &lt; 0 || maxValue &lt;= 0 || step &lt;= 0 || minValue &gt;= maxValue || maxValue - minValue &lt;= step ||seqValue &lt; minValue || seqValue &gt; maxValue ) &#123; return false; &#125; return true; &#125;&#125; DAO增删改查，其实就用到了改和查1234567891011121314public interface MysqlSequenceDAO &#123; /** * */ public int createSequence(MysqlSequenceBo bo); public int updSequence(@Param("seqName") String seqName, @Param("oldValue") long oldValue ,@Param("newValue") long newValue); public int delSequence(@Param("seqName") String seqName); public MysqlSequenceBo getSequence(@Param("seqName") String seqName); public List&lt;MysqlSequenceBo&gt; getAll();&#125; Mapper123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.xxxxx.core.sequence.impl.dao.MysqlSequenceDAO" &gt; &lt;resultMap id="BaseResultMap" type="com.xxxxx.core.sequence.impl.MysqlSequenceBo" &gt; &lt;result column="SEQ_NAME" property="seqName" jdbcType="VARCHAR" /&gt; &lt;result column="SEQ_VALUE" property="seqValue" jdbcType="BIGINT" /&gt; &lt;result column="MIN_VALUE" property="minValue" jdbcType="BIGINT" /&gt; &lt;result column="MAX_VALUE" property="maxValue" jdbcType="BIGINT" /&gt; &lt;result column="STEP" property="step" jdbcType="BIGINT" /&gt; &lt;result column="TM_CREATE" property="tmCreate" jdbcType="TIMESTAMP" /&gt; &lt;result column="TM_SMP" property="tmSmp" jdbcType="TIMESTAMP" /&gt; &lt;/resultMap&gt; &lt;delete id="delSequence" parameterType="java.lang.String" &gt; delete from t_pub_sequence where SEQ_NAME = #&#123;seqName,jdbcType=VARCHAR&#125; &lt;/delete&gt; &lt;insert id="createSequence" parameterType="com.xxxxx.core.sequence.impl.MysqlSequenceBo" &gt; insert into t_pub_sequence (SEQ_NAME,SEQ_VALUE,MIN_VALUE,MAX_VALUE,STEP,TM_CREATE) values (#&#123;seqName,jdbcType=VARCHAR&#125;, #&#123;seqValue,jdbcType=BIGINT&#125;, #&#123;minValue,jdbcType=BIGINT&#125;, #&#123;maxValue,jdbcType=BIGINT&#125;, #&#123;step,jdbcType=BIGINT&#125;, now()) &lt;/insert&gt; &lt;update id="updSequence" parameterType="com.xxxxx.core.sequence.impl.MysqlSequenceBo" &gt; update t_pub_sequence set SEQ_VALUE = #&#123;newValue,jdbcType=BIGINT&#125; where SEQ_NAME = #&#123;seqName,jdbcType=VARCHAR&#125; and SEQ_VALUE = #&#123;oldValue,jdbcType=BIGINT&#125; &lt;/update&gt; &lt;select id="getAll" resultMap="BaseResultMap" &gt; select SEQ_NAME, SEQ_VALUE, MIN_VALUE, MAX_VALUE, STEP from t_pub_sequence &lt;/select&gt; &lt;select id="getSequence" resultMap="BaseResultMap" &gt; select SEQ_NAME, SEQ_VALUE, MIN_VALUE, MAX_VALUE, STEP from t_pub_sequence where SEQ_NAME = #&#123;seqName,jdbcType=VARCHAR&#125; &lt;/select&gt;&lt;/mapper&gt; 接口实现12345678910111213141516171819@Repository("mysqlSequence")public class MysqlSequenceImpl implements MysqlSequence&#123; @Autowired private MysqlSequenceFactory mysqlSequenceFactory; /** * &lt;p&gt; * 获取指定sequence的序列号 * &lt;/p&gt; * * @param seqName sequence名 * @return String 序列号 * @author coderzl */ @Override public String nextVal(String seqName) &#123; return Objects.toString(mysqlSequenceFactory.getNextVal(seqName)); &#125;&#125; 工厂工厂只做了两件事 服务启动的时候，初始化数据库中所有sequence【完成序列区间缓存】 获取sequence的下一个值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Componentpublic class MysqlSequenceFactory &#123; private final Lock lock = new ReentrantLock(); /** */ private Map&lt;String,MysqlSequenceHolder&gt; holderMap = new ConcurrentHashMap&lt;&gt;(); @Autowired private MysqlSequenceDAO msqlSequenceDAO; /** 单个sequence初始化乐观锁更新失败重试次数 */ @Value("$&#123;seq.init.retry:5&#125;") private int initRetryNum; /** 单个sequence更新序列区间乐观锁更新失败重试次数 */ @Value("$&#123;seq.get.retry:20&#125;") private int getRetryNum; @PostConstruct private void init()&#123; //初始化所有sequence initAll(); &#125; /** * &lt;p&gt; 加载表中所有sequence，完成初始化 &lt;/p&gt; * @return void * @author coderzl */ private void initAll()&#123; try &#123; lock.lock(); List&lt;MysqlSequenceBo&gt; boList = msqlSequenceDAO.getAll(); if (boList == null) &#123; throw new IllegalArgumentException("The sequenceRecord is null!"); &#125; for (MysqlSequenceBo bo : boList) &#123; MysqlSequenceHolder holder = new MysqlSequenceHolder(msqlSequenceDAO, bo,initRetryNum,getRetryNum); holder.init(); holderMap.put(bo.getSeqName(), holder); &#125; &#125;finally &#123; lock.unlock(); &#125; &#125; /** * &lt;p&gt; &lt;/p&gt; * @param seqName * @return long * @author coderzl */ public long getNextVal(String seqName)&#123; MysqlSequenceHolder holder = holderMap.get(seqName); if (holder == null) &#123; try &#123; lock.lock(); holder = holderMap.get(seqName); if (holder != null)&#123; return holder.getNextVal(); &#125; MysqlSequenceBo bo = msqlSequenceDAO.getSequence(seqName); holder = new MysqlSequenceHolder(msqlSequenceDAO, bo,initRetryNum,getRetryNum); holder.init(); holderMap.put(seqName, holder); &#125;finally &#123; lock.unlock(); &#125; &#125; return holder.getNextVal(); &#125;&#125; 单一sequence的Holder init() 初始化 其中包括参数校验，数据库记录更新，创建序列区间 getNextVal() 获取下一个值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203public class MysqlSequenceHolder &#123; private final Lock lock = new ReentrantLock(); /** seqName */ private String seqName; /** sequenceDao */ private MysqlSequenceDAO sequenceDAO; private MysqlSequenceBo sequenceBo; /** */ private SequenceRange sequenceRange; /** 是否初始化 */ private volatile boolean isInitialize = false; /** sequence初始化重试次数 */ private int initRetryNum; /** sequence获取重试次数 */ private int getRetryNum; /** * &lt;p&gt; 构造方法 &lt;/p&gt; * @Title MysqlSequenceHolder * @param sequenceDAO * @param sequenceBo * @param initRetryNum 初始化时，数据库更新失败后重试次数 * @param getRetryNum 获取nextVal时，数据库更新失败后重试次数 * @return * @author coderzl */ public MysqlSequenceHolder(MysqlSequenceDAO sequenceDAO, MysqlSequenceBo sequenceBo,int initRetryNum,int getRetryNum) &#123; this.sequenceDAO = sequenceDAO; this.sequenceBo = sequenceBo; this.initRetryNum = initRetryNum; this.getRetryNum = getRetryNum; if(sequenceBo != null) this.seqName = sequenceBo.getSeqName(); &#125; /** * &lt;p&gt; 初始化 &lt;/p&gt; * @Title init * @param * @return void * @author coderzl */ public void init()&#123; if (isInitialize == true) &#123; throw new SequenceException("[" + seqName + "] the MysqlSequenceHolder has inited"); &#125; if (sequenceDAO == null) &#123; throw new SequenceException("[" + seqName + "] the sequenceDao is null"); &#125; if (seqName == null || seqName.trim().length() == 0) &#123; throw new SequenceException("[" + seqName + "] the sequenceName is null"); &#125; if (sequenceBo == null) &#123; throw new SequenceException("[" + seqName + "] the sequenceBo is null"); &#125; if (!sequenceBo.validate())&#123; throw new SequenceException("[" + seqName + "] the sequenceBo validate fail. BO:"+sequenceBo); &#125; // 初始化该sequence try &#123; initSequenceRecord(sequenceBo); &#125; catch (SequenceException e) &#123; throw e; &#125; isInitialize = true; &#125; /** * &lt;p&gt; 获取下一个序列号 &lt;/p&gt; * @Title getNextVal * @param * @return long * @author coderzl */ public long getNextVal()&#123; if(isInitialize == false)&#123; throw new SequenceException("[" + seqName + "] the MysqlSequenceHolder not inited"); &#125; if(sequenceRange == null)&#123; throw new SequenceException("[" + seqName + "] the sequenceRange is null"); &#125; long curValue = sequenceRange.getAndIncrement(); if(curValue == -1)&#123; try&#123; lock.lock(); curValue = sequenceRange.getAndIncrement(); if(curValue != -1)&#123; return curValue; &#125; sequenceRange = retryRange(); curValue = sequenceRange.getAndIncrement(); &#125;finally &#123; lock.unlock(); &#125; &#125; return curValue; &#125; /** * &lt;p&gt; 初始化当前这条记录 &lt;/p&gt; * @Title initSequenceRecord * @Description * @param sequenceBo * @return void * @author coderzl */ private void initSequenceRecord(MysqlSequenceBo sequenceBo)&#123; //在限定次数内，乐观锁更新数据库记录 for(int i = 1; i &lt; initRetryNum; i++)&#123; //查询bo MysqlSequenceBo curBo = sequenceDAO.getSequence(sequenceBo.getSeqName()); if(curBo == null)&#123; throw new SequenceException("[" + seqName + "] the current sequenceBo is null"); &#125; if (!curBo.validate())&#123; throw new SequenceException("[" + seqName + "] the current sequenceBo validate fail"); &#125; //改变当前值 long newValue = curBo.getSeqValue()+curBo.getStep(); //检查当前值 if(!checkCurrentValue(newValue,curBo))&#123; newValue = resetCurrentValue(curBo); &#125; int result = sequenceDAO.updSequence(sequenceBo.getSeqName(),curBo.getSeqValue(),newValue); if(result &gt; 0)&#123; sequenceRange = new SequenceRange(curBo.getSeqValue(),newValue - 1); curBo.setSeqValue(newValue); this.sequenceBo = curBo; return; &#125;else&#123; continue; &#125; &#125; //限定次数内，更新失败，抛出异常 throw new SequenceException("[" + seqName + "] sequenceBo update error"); &#125; /** * &lt;p&gt; 检查新值是否合法 新的当前值是否在最大最小值之间&lt;/p&gt; * @param curValue * @param curBo * @return boolean * @author coderzl */ private boolean checkCurrentValue(long curValue,MysqlSequenceBo curBo)&#123; if(curValue &gt; curBo.getMinValue() &amp;&amp; curValue &lt;= curBo.getMaxValue())&#123; return true; &#125; return false; &#125; /** * &lt;p&gt; 重置sequence当前值 ：当前sequence达到最大值时，重新从最小值开始 &lt;/p&gt; * @Title resetCurrentValue * @param curBo * @return long * @author coderzl */ private long resetCurrentValue(MysqlSequenceBo curBo)&#123; return curBo.getMinValue(); &#125; /** * &lt;p&gt; 缓存区间使用完毕时，重新读取数据库记录，缓存新序列段 &lt;/p&gt; * @Title retryRange * @param SequenceRange * @author coderzl */ private SequenceRange retryRange()&#123; for(int i = 1; i &lt; getRetryNum; i++)&#123; //查询bo MysqlSequenceBo curBo = sequenceDAO.getSequence(sequenceBo.getSeqName()); if(curBo == null)&#123; throw new SequenceException("[" + seqName + "] the current sequenceBo is null"); &#125; if (!curBo.validate())&#123; throw new SequenceException("[" + seqName + "] the current sequenceBo validate fail"); &#125; //改变当前值 long newValue = curBo.getSeqValue()+curBo.getStep(); //检查当前值 if(!checkCurrentValue(newValue,curBo))&#123; newValue = resetCurrentValue(curBo); &#125; int result = sequenceDAO.updSequence(sequenceBo.getSeqName(),curBo.getSeqValue(),newValue); if(result &gt; 0)&#123; sequenceRange = new SequenceRange(curBo.getSeqValue(),newValue - 1); curBo.setSeqValue(newValue); this.sequenceBo = curBo; return sequenceRange; &#125;else&#123; continue; &#125; &#125; throw new SequenceException("[" + seqName + "] sequenceBo update error"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring多数据源配置（未完成）]]></title>
      <url>%2F2017%2F06%2F04%2Fframework%2FSpring%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[项目团队最近需要更换框架，临时搭建一套组合框架。小项目，两个数据库：业务库，配置库。根据实际业务，动态切换。之前对这块配置处理没有什么了解，看了一些资料以及以前框架的实现，了解了下思路，做个笔记整理：1、自定义一个DataSource，Map存放所有数据源2、重写getConnection(),根据key值从map中获取DataSource，并返回连接3、定义一个上下文DataRouteContext 利用ThreadLocal 存储当前线程当前需要获取的数据源key值4、自定义一个注解@DataSource(“key”)5、自定义一个Aspect，拦截所有实现@DataSource注解的方法，将key值set到DataSourceContext 问题：如何把数据源key标记还原 public abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[马克吐槽]]></title>
      <url>%2F2017%2F06%2F04%2F%E9%9A%8F%E7%AC%94%2F%E9%A9%AC%E5%85%8B%E5%90%90%E6%A7%BD%2F</url>
      <content type="text"><![CDATA[前阵子开始，coding的免费用户开始有广告了，而且基本上照顾到站点的每个访问者，必然会见到一次/天。 博客一开始是放在了GitHub pages上了，但后来考虑到无法被百度收录，就添加了coding作为国内仓库。双仓库同步提交，云解析把默认请求解析到coding，海外请求解析到了GitHub。博客是靠三分钟的激情搭建起来的，然后开始偶尔把为知笔记上的笔记，转到博客上。晒网已久。。。上次看到广告，就琢磨着干掉coding的解析，结果随后一直没有写博客，也就不了了之……今天再次被广告恶心到，直接上云解析删掉了两个coding解析。 自家网络访问GitHub的速度比coding响应速度慢50-60ms，也算是可以接受了。。。毕竟博客也只是为了逼迫自己整理那混乱不堪的笔记。 继续撸代码，并努力再整理几篇笔记来装点一下这博客…… 补充更新：【Chrome DNS解析错误 问题解决方案】修改了云解析后，我的safari,firfox都能正常访问博客，虽然速度慢了点。但chrome一直访问不成功，直接跳转到www.zhanglong.wiki/pc.html，报【DNS解析错误】。后来发现，是chrome缓存一些解析，清空缓存就好了。或者：地址栏敲入：chrome://net-internals/#dns点击 clean host cache chrome版本：58.0.3029.110 (64-bit)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis分布式锁]]></title>
      <url>%2F2017%2F05%2F10%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2FRedis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
      <content type="text"><![CDATA[&gt;分布式锁是控制分布式系统之间同步访问共享资源的一种方式 锁接口定义 定义一个锁通用接口，对外提供锁服务 1234567891011121314151617181920212223242526import java.util.concurrent.TimeUnit;public interface LockService &#123; /** * 尝试获取锁 * @param 锁名 */ public boolean tryLock(String name); /** * 在指定时间内尝试获取锁 * @param 锁名 * @param 尝试时间 */ public boolean tryLock(String name, long timeout, TimeUnit unit); /** * 获取锁，阻塞方法，直到获取锁成功为止 * @param 锁名 */ public void lock(String name) throws Exception; /** * 释放锁 * @param 锁名 */ public void unlock(String name);&#125; redis锁的实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class RedisLockService implements LockService &#123; private static final String NAMESPACE = "lock-service:"; private static final Logger log = LogManager.getLogger(RedisLockService.class); @Autowired private RedisTemplate&lt;String, String&gt; stringRedisTemplate; /** 锁默认超时时间，单位：秒 */ @Value("$&#123;lockService.timeout:300&#125;") private int timeout; /** 服务ID，用于区分释放锁权限。 */ @Value("$&#123;instance.id:locks&#125;") private String instanceId; @Override public boolean tryLock(String name) &#123; String key = NAMESPACE + name; String value = getValue(); boolean success = stringRedisTemplate.opsForValue().setIfAbsent(key, value); //如果不存在key，则set if (success) stringRedisTemplate.expire(key, this.timeout, TimeUnit.SECONDS); //设置默认锁有效时间 return success; &#125; @Override public boolean tryLock(String name, long timeout, TimeUnit unit) &#123; if (timeout &lt;= 0) return tryLock(name); String key = NAMESPACE + name; String value = getValue(); boolean success = stringRedisTemplate.opsForValue().setIfAbsent(key, value); long millisTimeout = unit.toMillis(timeout); long start = System.currentTimeMillis(); while (!success) &#123; //若获取锁不成功，则在限定时间内不断尝试，直到获取成功，或超时 try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; return false; &#125; if ((System.currentTimeMillis() - start) &gt;= millisTimeout) break; success = stringRedisTemplate.opsForValue().setIfAbsent(key, value); &#125; if (success) stringRedisTemplate.expire(key, this.timeout, TimeUnit.SECONDS); return success; &#125; @Override public void lock(String name) &#123; String key = NAMESPACE + name; String value = getValue(); boolean success = stringRedisTemplate.opsForValue().setIfAbsent(key, value); while (!success) &#123; try &#123; Thread.sleep(100); //每间隔100毫秒，再次尝试获取锁 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; success = stringRedisTemplate.opsForValue().setIfAbsent(key, value); if (success) stringRedisTemplate.expire(key, this.timeout, TimeUnit.SECONDS); &#125; &#125; @Override public void unlock(String name) &#123; String key = NAMESPACE + name; String value = getValue(); //一行lua脚本，如果KEY的值等于VALUE，则删除KEY，否则返回0 String str = "if redis.call(\"get\",KEYS[1]) == ARGV[1] then return redis.call(\"del\",KEYS[1]) else return 0 end"; RedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;Long&gt;(str, Long.class); Long ret = stringRedisTemplate.execute(script, Collections.singletonList(key), value); if (ret == 0) log.warn("Lock [&#123;&#125;] is not hold by instance [&#123;&#125;]", name, value); &#125; /** * 生成由服务ID+线程名组成的线程唯一value。用于保证只能被拥有锁的线程解锁 */ private String getValue()&#123; return instanceId + Thread.currentThread().getName(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo + Github Pages 搭建静态博客]]></title>
      <url>%2F2017%2F04%2F16%2Fhexo%2F</url>
      <content type="text"><![CDATA[利用hexo和github pages搭建静态博客，主要操作步骤有： 1、搭建node.js环境 2、安装hexo 3、用hexo初始化生成一个静态博客文件 4、生成静态html页面 5、本地起服务调试 6、配置github仓库地址 7、发布 安装Node.jsURL: 下载 安装Hexo1$ sudo npm install -g hexo 初始化1$ hexo init INFO Start blogging with Hexo! 生成静态页面1$ hexo g 启动服务hexo可以在本地调试，1$ hexo server 配置发布信息Github打开根目录_config.yml 在文件最后，修改deploy节点1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 执行命令1$ npm install hexo-deployer-git --save 发布1$ hexo deploy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo主题配置]]></title>
      <url>%2F2017%2F04%2F16%2Fhexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[选择hexo很重要的一个原因就是它丰富的主题，而配置主题的流程也很简单：1、clone主题到本地2、修改_config.yml配置3、重新生成静态页面、发布 下载主题hexo官网有很多丰富的主题，选择一个，进入到它的GitHub页面12$ cd yourBlogdir/themes$ git clone xxx.git 修改配置打开博客根目录下的_config.yml配置文件，找到theme: 节点，将值改成下载的主题名。如：1theme: yilia 重新发布123$ hexo clean //删除本地原有静态页面$ hexo g //重新生成静态页面$ hexo d //发布到GitHub 一个新的主题，肯定会存在一些个性化的配置，这些就需要去看对应主题的相关readme了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql加锁分析]]></title>
      <url>%2F2017%2F03%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fmysql%E5%8A%A0%E9%94%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[原文地址：http://hedengcheng.com/?p=771 待有时间把笔记丢上来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[红黑树详解及代码(待更新)]]></title>
      <url>%2F2017%2F01%2F12%2Fjdk%2F%E7%BA%A2%E9%BB%91%E6%A0%91%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81%2F</url>
      <content type="text"><![CDATA[R-B Tree简介R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树的特性:（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 注意：(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。 1234567891011121314151617181920212223 public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; &#123; private RBTNode root; private static final boolean RED = false; private static final boolean BLACK = true; private class RBTNode&lt;T extends Comparable&lt;T&gt;&gt;&#123; boolean color; // 颜色 T key; // 关键字(键值) RBTNode&lt;T&gt; left; // 左孩子 RBTNode&lt;T&gt; right; // 右孩子 RBTNode&lt;T&gt; parent; // 父结点 public RBTNode(T key, boolean color, RBTNode&lt;T&gt; parent, RBTNode&lt;T&gt; left, RBTNode&lt;T&gt; right) &#123; this.key = key; this.color = color; this.parent = parent; this.left = left; this.right = right; &#125; ...&#125; 左旋：当前节点X，a.原右子节点Y-&gt;变成了父节点b.原右子节点的左子节点ß-&gt;变成了X的右子节点 12345678910111213141516171819202122232425262728private void leftSpin(RBTNode currentNode)&#123; //X RBTNode rightChild = currentNode.getRight(); //当前节点的右子节点 Y RBTNode parent = currentNode.getParent(); //设置当前节点的父节点为右子节点 currentNode.setParent(rightChild); // rightChild.setParent(parent); if(parent != null)&#123; // if(parent.getLeft() == currentNode)&#123; parent.setLeft(rightChild); &#125;else&#123; parent.setRight(rightChild); &#125; &#125;else&#123; this.root = currentNode.getParent(); &#125; //设置原右子节点的左子节点为当前节点 rightChild.setLeft(currentNode); //设置当前节点的右子节点为原右子节点的左子节点 currentNode.setRight(rightChild.getLeft()); if(currentNode.getRight() != null)&#123; currentNode.getRight().setParent(currentNode); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ArrayList源码笔记(1.8)]]></title>
      <url>%2F2017%2F01%2F10%2Fjdk%2FArrayList%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[ArrayList 是一个依靠 Arrays.copyOf 方法进行动态扩展的数组。增删改查本质上都是对数组进行操作，只是存在容量动态扩展的的逻辑 简介ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 线程不安全。 属性12345678910111213141516171819202122/** * 默认初始容量. */private static final int DEFAULT_CAPACITY = 10;/** * 空数组，构造初始容量为0时使用 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 默认初始化数组. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存List数据的数组，如果List是默认初始化，当第一个元素添加时，elementData大小变成DEFAULT_CAPACITY */transient Object[] elementData; // transient不参与序列化（由readObjet()，writeObject()解决序列/反序列初始化问题）/** * 容器里元素个数 * @serial */private int size; 构造函数1234567891011121314151617181920212223242526272829303132/** 指定List大小 */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;/** * 默认 */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * 一个包含Collection的List */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // c大小为0 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 容量调整方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 将数组大小设置为元素个数 */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125;/** * 让用户设置容器大小 */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;/** * 确认容器大小，如果容器是默认初始化，则最小容量置为DEFAULT_CAPACITY【检查1】 */private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;/** * 确认容器大小，如果最小期望的容量不够，则增加【检查2】 */private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * 数组可以分配的最大值 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * 增加数组容量，使之能达到期望大小 * @param minCapacity 期望的最小容量 */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;/** * 获取一个大的容量 */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 增删改查增提供的添加方法有add(E e),add(int index, E element),addAll(Collection&lt;? extends E&gt; c),addAll(int index, Collection&lt;? extends E&gt; c) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 添加元素 */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 确认容量，长度不足就扩容 elementData[size++] = e; return true;&#125;/** * 添加到指定位置 */public void add(int index, E element) &#123; rangeCheckForAdd(index);//检查index有没有大于当前元素个数，有没有小于0 ensureCapacityInternal(size + 1); // 确认容量，长度不足就扩容 System.arraycopy(elementData, index, elementData, index + 1, size - index);//index后面的统一往后移一位 elementData[index] = element; size++;&#125;/** * 增加一个Collection */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 确认容量，长度不足就扩容 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;/** * 将Collection插入到指定位置 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 删删除的方法remove(int index),remove(Object o),fastRemove(int index),clear(),removeAll(Collection&lt;?&gt; c),retainAll(Collection&lt;?&gt; c),removeRange(int fromIndex, int toIndex) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 删除指定位置元素 */public E remove(int index) &#123; rangeCheck(index);//index边界检查 modCount++;//新增修改记录数 E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;/** * 删除指定元素，首个出现的 */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/* * 删除指定位置元素，不做index越界检查 */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;/** * 删除所有 */public void clear() &#123; modCount++; //变更修改次数 // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125;/** * 批量删除 删除包含C的 */public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125;/** * 批量删除 删除不包含C的 */public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125;/** * 删除从fromIndex到toIndex的元素 */protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125; 改12345678910/** * 修改index位置的元素 */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 查查询方法get(int index),indexOf(Object o),indexOf(Object o),indexOf(Object o),contains(Object o) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 获取指定位置的元素 */public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125;/** * 遍历查找O首次出现的位置，没有返回-1 */public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * 返回o出现的最后一次位置 */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * 是否包含 */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 序列化一句话：都是流 并发线程不安全 [参考]http://www.cnblogs.com/skywang12345/p/3308556.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LinkedList源码笔记(1.8)]]></title>
      <url>%2F2017%2F01%2F10%2Fjdk%2FLinkedList%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[LinkedList 双向链表。插入删除，最多都只需要修改三个Node，速度较快根据index查询，最多需要遍历半个链表（node(int index) 方法会判断从头遍历还是从尾遍历） 简介 构造函数1234567public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 属性12345transient int size = 0; //元素个数 transient Node&lt;E&gt; first; //链表头transient Node&lt;E&gt; last; //链表尾 Node1234567891011private static class Node&lt;E&gt; &#123; E item;//存储元素 Node&lt;E&gt; next;//下一个 Node&lt;E&gt; prev;//上一个 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 增删改查增123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 在链表末端插入一个元素 */public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * 在链表末端插入一个元素 */public void addLast(E e) &#123; linkLast(e);&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last;//获取链表尾节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);//创建Node节点 last = newNode;//修改链表尾节点 if (l == null)//链表是空的 first = newNode; else l.next = newNode; size++; modCount++;&#125;/** * 在链表首端插入一个元素 */public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125; 删1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 删除首节点 * 如果链表没有元素，会报NoSuchElementException */public E remove() &#123; return removeFirst();&#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;/** * 删除指定位置元素 */public E remove(int index) &#123; checkElementIndex(index);//检查index边界 return unlink(node(index));&#125;/** * 找到第index个Node */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; //index小于size一半，从头节点开始遍历 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123;//从尾节点开始遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;/** * 移除指定节点 */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; //C final Node&lt;E&gt; prev = x.prev; //A if (prev == null) &#123; first = next; //如果是头，直接把next设置为头 &#125; else &#123; prev.next = next; //A-&gt;B-&gt;C ==&gt; A-&gt;C x.prev = null; &#125; if (next == null) &#123; last = prev; //如果是尾，直接prev设置为尾 &#125; else &#123; next.prev = prev; //A&lt;-B&lt;-C ==&gt; A&lt;-C x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125;/** * 删除尾节点 */public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125; 改1234567891011/** * 修改 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; checkElementIndex(index);//检查边界 Node&lt;E&gt; x = node(index);//找到指定index的Node E oldVal = x.item; x.item = element; return oldVal;&#125; 查12345678/** * 查找 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; 队列、栈LinkedList可以不作任何修改，直接当做队列，栈使用。]]></content>
    </entry>

    
  
  
</search>
