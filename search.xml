<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hexo + Github Pages 搭建静态博客]]></title>
      <url>%2F2017%2F04%2F16%2Fhexo%2F</url>
      <content type="text"><![CDATA[利用hexo和github pages搭建静态博客，主要操作步骤有： 1、搭建node.js环境 2、安装hexo 3、用hexo初始化生成一个静态博客文件 4、生成静态html页面 5、本地起服务调试 6、配置github仓库地址 7、发布 安装Node.jsURL: 下载 安装Hexo1$ sudo npm install -g hexo 初始化1$ hexo init INFO Start blogging with Hexo! 生成静态页面1$ hexo g 启动服务hexo可以在本地调试，1$ hexo server 配置发布信息Github打开根目录_config.yml 在文件最后，修改deploy节点1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 执行命令1$ npm install hexo-deployer-git --save 发布1$ hexo deploy]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo主题配置]]></title>
      <url>%2F2017%2F04%2F16%2Fhexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[选择hexo很重要的一个原因就是它丰富的主题，而配置主题的流程也很简单：1、clone主题到本地2、修改_config.yml配置3、重新生成静态页面、发布 下载主题hexo官网有很多丰富的主题，选择一个，进入到它的GitHub页面12$ cd yourBlogdir/themes$ git clone xxx.git 修改配置打开博客根目录下的_config.yml配置文件，找到theme: 节点，将值改成下载的主题名。如：1theme: yilia 重新发布123$ hexo clean //删除本地原有静态页面$ hexo g //重新生成静态页面$ hexo d //发布到GitHub 一个新的主题，肯定会存在一些个性化的配置，这些就需要去看对应主题的相关readme了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ArrayList源码笔记(1.8)]]></title>
      <url>%2F2017%2F01%2F10%2FArrayList%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[ArrayList 是一个依靠 Arrays.copyOf 方法进行动态扩展的数组。增删改查本质上都是对数组进行操作，只是存在容量动态扩展的的逻辑 简介ArrayList 是一个数组队列，相当于 动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。 ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。 ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。 线程不安全。 &lt;– more –&gt; 属性12345678910111213141516171819202122/** * 默认初始容量. */private static final int DEFAULT_CAPACITY = 10;/** * 空数组，构造初始容量为0时使用 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 默认初始化数组. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; /** * 保存List数据的数组，如果List是默认初始化，当第一个元素添加时，elementData大小变成DEFAULT_CAPACITY */transient Object[] elementData; // transient不参与序列化（由readObjet()，writeObject()解决序列/反序列初始化问题）/** * 容器里元素个数 * @serial */private int size; 构造函数1234567891011121314151617181920212223242526272829303132/** 指定List大小 */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;/** * 默认 */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * 一个包含Collection的List */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // c大小为0 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 容量调整方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * 将数组大小设置为元素个数 */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125;/** * 让用户设置容器大小 */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;/** * 确认容器大小，如果容器是默认初始化，则最小容量置为DEFAULT_CAPACITY【检查1】 */private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;/** * 确认容器大小，如果最小期望的容量不够，则增加【检查2】 */private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * 数组可以分配的最大值 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * 增加数组容量，使之能达到期望大小 * @param minCapacity 期望的最小容量 */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;/** * 获取一个大的容量 */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 增删改查增加提供的添加方法有add(E e),add(int index, E element),addAll(Collection&lt;? extends E&gt; c),addAll(int index, Collection&lt;? extends E&gt; c) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 添加元素 */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 确认容量，长度不足就扩容 elementData[size++] = e; return true;&#125;/** * 添加到指定位置 */public void add(int index, E element) &#123; rangeCheckForAdd(index);//检查index有没有大于当前元素个数，有没有小于0 ensureCapacityInternal(size + 1); // 确认容量，长度不足就扩容 System.arraycopy(elementData, index, elementData, index + 1, size - index);//index后面的统一往后移一位 elementData[index] = element; size++;&#125;/** * 增加一个Collection */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // 确认容量，长度不足就扩容 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;/** * 将Collection插入到指定位置 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 删除删除的方法remove(int index),remove(Object o),fastRemove(int index),clear(),removeAll(Collection&lt;?&gt; c),retainAll(Collection&lt;?&gt; c),removeRange(int fromIndex, int toIndex) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 删除指定位置元素 */public E remove(int index) &#123; rangeCheck(index);//index边界检查 modCount++;//新增修改记录数 E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;/** * 删除指定元素，首个出现的 */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/* * 删除指定位置元素，不做index越界检查 */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;/** * 删除所有 */public void clear() &#123; modCount++; //变更修改次数 // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125;/** * 批量删除 删除包含C的 */public boolean removeAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, false);&#125;/** * 批量删除 删除不包含C的 */public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125;/** * 删除从fromIndex到toIndex的元素 */protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125; 改12345678910/** * 修改index位置的元素 */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 查查询方法get(int index),indexOf(Object o),indexOf(Object o),indexOf(Object o),contains(Object o) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 获取指定位置的元素 */public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125;/** * 遍历查找O首次出现的位置，没有返回-1 */public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * 返回o出现的最后一次位置 */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * 是否包含 */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 序列化一句话：都是流 并发线程不安全 [参考]http://www.cnblogs.com/skywang12345/p/3308556.html]]></content>
    </entry>

    
  
  
</search>
